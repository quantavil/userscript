
====================
File: src/core/file-writer.ts
====================

/**
 * File writing with streaming support
 * Uses File System Access API when available, falls back to in-memory blob
 */

export interface FileWriter {
  write(chunk: Uint8Array): Promise<void>;
  close(): Promise<void>;
  abort(): void;
}

/**
 * Create a file writer
 * Tries native File System Access API first, falls back to blob accumulation
 */
export async function createFileWriter(
  suggestedName: string,
  mimeType: string
): Promise<FileWriter> {
  // Try File System Access API (Chrome/Edge)
  if (typeof window.showSaveFilePicker === 'function') {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [{
          description: 'Video file',
          accept: { [mimeType]: [`.${suggestedName.split('.').pop()}`] },
        }],
      });
      
      const stream = await handle.createWritable();
      
      return {
        async write(chunk: Uint8Array): Promise<void> {
          await stream.write(chunk);
        },
        async close(): Promise<void> {
          await stream.close();
          GM_notification({
            text: `Download complete: ${suggestedName}`,
            title: 'StreamGrabber',
            timeout: 3000,
          });
        },
        abort(): void {
          try { stream.abort(); } catch { /* ignore */ }
        },
      };
    } catch (e) {
      // User cancelled or API failed, fall through to blob method
      if ((e as Error).name === 'AbortError') {
        throw e; // Re-throw user cancellation
      }
    }
  }
  
  // Fallback: accumulate in memory, download via GM_download
  const chunks: Uint8Array[] = [];
  let aborted = false;
  
  return {
    async write(chunk: Uint8Array): Promise<void> {
      if (aborted) return;
      chunks.push(chunk);
    },
    async close(): Promise<void> {
      if (aborted) return;
      
      const blob = new Blob(chunks, { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      return new Promise((resolve, reject) => {
        GM_download({
          url,
          name: suggestedName,
          onload: () => {
            URL.revokeObjectURL(url);
            GM_notification({
              text: `Download complete: ${suggestedName}`,
              title: 'StreamGrabber',
              timeout: 3000,
            });
            resolve();
          },
          onerror: (err) => {
            URL.revokeObjectURL(url);
            reject(new Error(`Download failed: ${err}`));
          },
        });
      });
    },
    abort(): void {
      aborted = true;
      chunks.length = 0;
    },
  };
}

====================
File: src/core/network.ts
====================

import type { HeadMeta, AbortablePromise, GmRequestOptions, BlobInfo } from '../types';
import { CFG, CACHE } from '../config';
import { isBlob, parseRange, once } from '../utils';

// ============================================
// Caches
// ============================================

const textCache = new Map<string, string>();
const textInflight = new Map<string, Promise<string>>();
const headCache = new Map<string, HeadMeta>();
const headInflight = new Map<string, Promise<HeadMeta>>();

// Blob registry (populated by detection hooks)
export const blobRegistry = new Map<string, BlobInfo>();

// ============================================
// Core GM Request
// ============================================

export function gmGet<T extends 'text' | 'arraybuffer'>(
  opts: GmRequestOptions & { responseType: T }
): AbortablePromise<T extends 'text' ? string : ArrayBuffer> {
  let ref: ReturnType<typeof GM_xmlhttpRequest> | null = null;
  
  const p = new Promise<T extends 'text' ? string : ArrayBuffer>((resolve, reject) => {
    ref = GM_xmlhttpRequest({
      method: 'GET',
      url: opts.url,
      responseType: opts.responseType,
      headers: opts.headers || {},
      timeout: opts.timeout ?? CFG.REQUEST_TIMEOUT,
      onprogress: (e) => opts.onprogress?.({ loaded: e.loaded, total: e.total }),
      onload: (r) => {
        if (r.status >= 200 && r.status < 300) {
          resolve(r.response as T extends 'text' ? string : ArrayBuffer);
        } else {
          reject(new Error(`HTTP ${r.status}`));
        }
      },
      onerror: () => reject(new Error('Network error')),
      ontimeout: () => reject(new Error('Timeout')),
    });
  }) as AbortablePromise<T extends 'text' ? string : ArrayBuffer>;
  
  p.abort = () => {
    try { ref?.abort(); } catch { /* ignore */ }
  };
  
  return p;
}

// ============================================
// Text Fetching (with cache)
// ============================================

async function fetchText(url: string): Promise<string> {
  if (isBlob(url)) {
    const info = blobRegistry.get(url);
    if (!info?.blob) throw new Error('Blob not found');
    info.ts = Date.now();
    return info.blob.text();
  }
  return gmGet({
    url,
    responseType: 'text',
    timeout: CFG.MANIFEST_TIMEOUT,
  });
}

export function getText(url: string): Promise<string> {
  return once(textCache, textInflight, url, () => fetchText(url), CACHE.TEXT_MAX);
}

// ============================================
// Binary Fetching
// ============================================

export function getBin(
  url: string,
  headers: Record<string, string> = {},
  timeout = CFG.REQUEST_TIMEOUT,
  onprogress?: (e: { loaded: number; total: number }) => void
): Promise<ArrayBuffer> {
  if (isBlob(url)) {
    const info = blobRegistry.get(url);
    if (!info?.blob) return Promise.reject(new Error('Blob not found'));
    info.ts = Date.now();
    
    const range = parseRange(headers.Range);
    const part = range
      ? info.blob.slice(range.start, range.end == null ? info.blob.size : range.end + 1)
      : info.blob;
    
    if (onprogress) {
      setTimeout(() => onprogress({ loaded: part.size, total: part.size }), 0);
    }
    return part.arrayBuffer();
  }
  
  return gmGet({
    url,
    responseType: 'arraybuffer',
    headers,
    timeout,
    onprogress,
  });
}

// ============================================
// HEAD Request (with cache)
// ============================================

async function fetchHead(url: string): Promise<HeadMeta> {
  try {
    const resp = await new Promise<{ responseHeaders: string }>((resolve, reject) => {
      GM_xmlhttpRequest({
        method: 'HEAD',
        url,
        timeout: CFG.REQUEST_TIMEOUT,
        onload: resolve,
        onerror: () => reject(new Error('HEAD failed')),
        ontimeout: () => reject(new Error('HEAD timeout')),
      });
    });
    
    const h = resp.responseHeaders || '';
    const lengthMatch = /(^|\n)content-length:\s*(\d+)/i.exec(h);
    const typeMatch = /(^|\n)content-type:\s*([^\n]+)/i.exec(h);
    
    return {
      length: lengthMatch ? +lengthMatch[2] : null,
      type: typeMatch ? typeMatch[2].trim() : null,
    };
  } catch {
    return { length: null, type: null };
  }
}

export function headMeta(url: string): Promise<HeadMeta> {
  return once(headCache, headInflight, url, () => fetchHead(url), CACHE.HEAD_MAX);
}

// ============================================
// Cache Maintenance
// ============================================

export function clearNetworkCaches(): void {
  textCache.clear();
  textInflight.clear();
  headCache.clear();
  headInflight.clear();
}

====================
File: src/core/parser.ts
====================

import { parse, types } from 'hls-parser';
import type { Variant, Segment, SegmentKey, SegmentMap, ParsedMedia } from '../types';
import { safeAbsUrl, parseRange } from '../utils';

// ============================================
// Manifest Parsing
// ============================================

export interface ParsedManifest {
  isMaster: boolean;
  // Master playlist data
  variants?: Variant[];
  // Media playlist data
  segments?: Segment[];
  mediaSeq?: number;
  endList?: boolean;
  targetDuration?: number;
}

/**
 * Parse HLS manifest text
 */
export function parseManifest(text: string, baseUrl: string): ParsedManifest {
  const manifest = parse(text);
  
  if (manifest.isMasterPlaylist) {
    return {
      isMaster: true,
      variants: buildVariants(manifest as types.MasterPlaylist, baseUrl),
    };
  }
  
  const media = manifest as types.MediaPlaylist;
  const parsed = buildMedia(media, baseUrl);
  
  return {
    isMaster: false,
    segments: parsed.segs,
    mediaSeq: parsed.mediaSeq,
    endList: parsed.endList,
    targetDuration: media.targetDuration,
  };
}

// ============================================
// Variant Building (Master Playlist)
// ============================================

function buildVariants(master: types.MasterPlaylist, baseUrl: string): Variant[] {
  const out: Variant[] = [];
  
  for (const v of master.variants) {
    if (!v.uri) continue;
    
    const res = v.resolution;
    const w = res?.width ?? null;
    const h = res?.height ?? null;
    
    out.push({
      url: safeAbsUrl(v.uri, baseUrl),
      res: w && h ? `${w}x${h}` : null,
      w,
      h,
      peak: v.bandwidth ?? null,
      avg: v.averageBandwidth ?? null,
      codecs: v.codecs ?? null,
    });
  }
  
  return out;
}

// ============================================
// Segment Building (Media Playlist)
// ============================================

interface ByterangeResult {
  header: string | null;
  next: number;
}

function rangeHeaderFromByterange(
  br: types.Byterange | undefined,
  fallbackStart: number
): ByterangeResult {
  if (!br || typeof br.length !== 'number') {
    return { header: null, next: fallbackStart };
  }
  
  const start = typeof br.offset === 'number' ? br.offset : fallbackStart;
  const end = start + br.length - 1;
  
  return {
    header: `bytes=${start}-${end}`,
    next: end + 1,
  };
}

function buildMedia(media: types.MediaPlaylist, baseUrl: string): ParsedMedia {
  const segs: Segment[] = [];
  let lastNext = 0;
  let prevMapSig: string | null = null;
  
  for (let i = 0; i < media.segments.length; i++) {
    const s = media.segments[i];
    
    // Handle byterange
    let rangeHeader: string | null = null;
    if (s.byterange) {
      const r = rangeHeaderFromByterange(s.byterange, lastNext);
      rangeHeader = r.header;
      lastNext = r.next;
    } else {
      lastNext = 0;
    }
    
    // Handle init segment (fMP4)
    let map: SegmentMap | null = null;
    let needMap = false;
    
    if (s.map?.uri) {
      const mapUri = safeAbsUrl(s.map.uri, baseUrl);
      let mRange: string | null = null;
      
      if (s.map.byterange) {
        const mr = rangeHeaderFromByterange(s.map.byterange, 0);
        mRange = mr.header;
      }
      
      map = { uri: mapUri, rangeHeader: mRange };
      
      // Only include map if it changed
      const sig = `${mapUri}|${mRange || ''}`;
      needMap = sig !== prevMapSig;
      if (needMap) prevMapSig = sig;
    }
    
    // Handle encryption key
    let key: SegmentKey | null = null;
    if (s.key?.method && s.key.method !== 'NONE') {
      key = {
        method: String(s.key.method).toUpperCase(),
        uri: s.key.uri ? safeAbsUrl(s.key.uri, baseUrl) : null,
        iv: s.key.iv?.toString() ?? null,
      };
    }
    
    segs.push({
      uri: safeAbsUrl(s.uri, baseUrl),
      dur: s.duration || 0,
      range: rangeHeader,
      key,
      map,
      needMap,
    });
  }
  
  return {
    segs,
    mediaSeq: media.mediaSequenceBase || 0,
    endList: media.endlist ?? false,
  };
}

// ============================================
// Size Estimation
// ============================================

export interface SizeEstimate {
  bytes: number | null;
  seconds: number;
  vod: boolean;
  via: 'byterange' | 'avg-bw' | 'unknown';
}

/**
 * Compute exact size from byterange segments
 */
export function computeExactBytes(parsed: ParsedMedia): number | null {
  let exact = true;
  let total = 0;
  const seenInit = new Set<string>();
  
  for (const s of parsed.segs) {
    if (s.range) {
      const r = parseRange(s.range);
      if (!r || r.end == null) {
        exact = false;
      } else {
        total += r.end - r.start + 1;
      }
    } else {
      exact = false;
    }
    
    // Count init segments
    if (s.needMap && s.map) {
      if (s.map.rangeHeader) {
        const key = `${s.map.uri}|${s.map.rangeHeader}`;
        if (!seenInit.has(key)) {
          seenInit.add(key);
          const mr = parseRange(s.map.rangeHeader);
          if (!mr || mr.end == null) {
            exact = false;
          } else {
            total += mr.end - mr.start + 1;
          }
        }
      } else {
        exact = false;
      }
    }
  }
  
  return exact ? total : null;
}

/**
 * Estimate HLS size from manifest
 */
export function estimateHlsSize(
  parsed: ParsedMedia,
  totalDuration: number,
  variant: Variant | null
): SizeEstimate {
  const vod = parsed.endList;
  
  // Try exact byterange calculation
  const exactBytes = computeExactBytes(parsed);
  if (exactBytes != null) {
    return { bytes: exactBytes, seconds: totalDuration, vod, via: 'byterange' };
  }
  
  // Fall back to bandwidth estimation
  const bw = variant?.avg ?? variant?.peak ?? null;
  if (vod && bw && totalDuration > 0) {
    return {
      bytes: Math.round((bw / 8) * totalDuration),
      seconds: totalDuration,
      vod,
      via: 'avg-bw',
    };
  }
  
  return { bytes: null, seconds: totalDuration, vod, via: 'unknown' };
}

/**
 * Calculate total duration from segments
 */
export function calcDuration(segments: Segment[]): number {
  return segments.reduce((sum, s) => sum + s.dur, 0);
}

/**
 * Check if segments use fMP4 format
 */
export function isFmp4(segments: Segment[]): boolean {
  if (segments.length === 0) return false;
  return segments.some(s => s.map) || /\.m4s(\?|$)/i.test(segments[0].uri);
}

/**
 * Check if any segment is encrypted
 */
export function hasEncryption(segments: Segment[]): boolean {
  return segments.some(s => s.key?.method === 'AES-128');
}

====================
File: src/detection/hooks.ts
====================

import type { BlobInfo } from '../types';
import { blobRegistry } from '../core/network';
import { looksM3U8Type, looksVideoType } from '../utils';

type DetectionCallback = (url: string, metadata?: { size?: number; type?: string }) => void;

let onDetect: DetectionCallback = () => {};

/**
 * Set the detection callback
 */
export function setDetectionCallback(cb: DetectionCallback): void {
  onDetect = cb;
}

// ============================================
// createObjectURL Hook
// ============================================

function hookCreateObjectURL(): void {
  const original = URL.createObjectURL;
  
  URL.createObjectURL = function (obj: Blob | MediaSource): string {
    const href = original.call(this, obj);
    
    try {
      const now = Date.now();
      
      if (obj instanceof Blob) {
        const type = obj.type || '';
        const info: BlobInfo = {
          blob: obj,
          type,
          size: obj.size,
          kind: 'other',
          ts: now,
        };
        
        if (looksM3U8Type(type)) {
          info.kind = 'm3u8';
          blobRegistry.set(href, info);
          onDetect(href);
        } else if (looksVideoType(type)) {
          info.kind = 'video';
          blobRegistry.set(href, info);
          onDetect(href);
        } else {
          // Check content for ambiguous types
          const needsCheck = /octet-stream|text\/plain|^$/.test(type);
          if (needsCheck && obj.size > 0) {
            obj.slice(0, Math.min(2048, obj.size)).text()
              .then(text => {
                if (/^#EXTM3U/i.test(text)) {
                  info.kind = 'm3u8';
                }
                blobRegistry.set(href, info);
                if (info.kind === 'm3u8') {
                  onDetect(href);
                }
              })
              .catch(() => {
                blobRegistry.set(href, info);
              });
          } else {
            blobRegistry.set(href, info);
          }
        }
      } else {
        // MediaSource
        blobRegistry.set(href, {
          blob: null,
          type: 'mediasource',
          size: 0,
          kind: 'other',
          ts: now,
        });
      }
    } catch (e) {
      console.error('[SG] createObjectURL hook error:', e);
    }
    
    return href;
  };
}

function hookRevokeObjectURL(): void {
  const original = URL.revokeObjectURL;
  
  URL.revokeObjectURL = function (href: string): void {
    try {
      const info = blobRegistry.get(href);
      if (info) {
        info.revoked = true;
        info.ts = Date.now();
      }
    } catch { /* ignore */ }
    
    return original.call(this, href);
  };
}

// ============================================
// Fetch Hook
// ============================================

function hookFetch(): void {
  const original = window.fetch;
  if (typeof original !== 'function') return;
  
  window.fetch = function (...args: Parameters<typeof fetch>): Promise<Response> {
    try {
      const input = args[0];
      const url = typeof input === 'string' ? input : input?.url;
      if (url) onDetect(url);
    } catch { /* ignore */ }
    
    return original.apply(this, args);
  };
}

// ============================================
// XHR Hook
// ============================================

function hookXHR(): void {
  const original = XMLHttpRequest.prototype.open;
  
  XMLHttpRequest.prototype.open = function (
    method: string,
    url: string | URL,
    ...rest: unknown[]
  ): void {
    try {
      const urlStr = typeof url === 'string' ? url : url?.href;
      if (urlStr) onDetect(urlStr);
    } catch { /* ignore */ }
    
    // @ts-expect-error - rest params typing
    return original.call(this, method, url, ...rest);
  };
}

// ============================================
// Performance Observer
// ============================================

function hookPerformanceObserver(): void {
  try {
    const observer = new PerformanceObserver(list => {
      for (const entry of list.getEntries()) {
        if ('name' in entry && typeof entry.name === 'string') {
          onDetect(entry.name);
        }
      }
    });
    observer.observe({ entryTypes: ['resource'] });
  } catch { /* ignore - not supported */ }
}

// ============================================
// Install All Hooks
// ============================================

let hooksInstalled = false;

export function installHooks(): void {
  if (hooksInstalled) return;
  hooksInstalled = true;
  
  hookCreateObjectURL();
  hookRevokeObjectURL();
  hookFetch();
  hookXHR();
  hookPerformanceObserver();
}

====================
File: src/detection/index.ts
====================

import type { MediaItem } from '../types';
import { CFG } from '../config';
import { state } from '../state';
import { blobRegistry } from '../core/network';
import {
  isHttp,
  isBlob,
  isM3U8Url,
  isVideoUrl,
  isSegmentUrl,
  guessExt,
  extractResFromUrl,
} from '../utils';
import { installHooks, setDetectionCallback } from './hooks';
import { scanVideos, startVideoObserver, setScanCallback } from './video-scanner';

// ============================================
// Debouncing
// ============================================

const pendingUrls = new Set<string>();

function debounceDetect(url: string, callback: (url: string) => void): void {
  if (pendingUrls.has(url)) return;
  pendingUrls.add(url);
  
  setTimeout(() => {
    pendingUrls.delete(url);
    callback(url);
  }, CFG.DETECT_DEBOUNCE);
}

// ============================================
// Item Creation
// ============================================

function createMediaItem(
  url: string,
  kind: 'hls' | 'video',
  metadata: { size?: number | null; type?: string | null } = {}
): MediaItem {
  const { size = null, type = null } = metadata;
  
  // Generate initial label
  let label: string;
  if (kind === 'hls') {
    const res = extractResFromUrl(url);
    label = res ? `${res} â€¢ Analyzing...` : 'Analyzing...';
  } else {
    label = guessExt(url, type).toUpperCase();
  }
  
  return {
    url,
    kind,
    label,
    sublabel: null,
    size,
    type,
    origin: document.location.origin,
    enriched: false,
    enriching: false,
    hlsType: null,
    isLive: false,
    encrypted: false,
    _enrichPromise: null,
  };
}

// ============================================
// Detection Handler
// ============================================

export type OnItemDetected = (item: MediaItem) => void;

let onItemDetected: OnItemDetected = () => {};

export function setItemDetectedCallback(cb: OnItemDetected): void {
  onItemDetected = cb;
}

function processUrl(url: string): void {
  try {
    // Validate URL
    if (!url || (!isHttp(url) && !isBlob(url))) return;
    
    // Skip segment URLs (fragments, not full videos)
    if (isSegmentUrl(url)) return;
    
    // Skip already detected
    if (state.hasItem(url)) return;
    
    // Get metadata from blob registry
    let size: number | null = null;
    let type: string | null = null;
    
    if (isBlob(url)) {
      const info = blobRegistry.get(url);
      if (info) {
        size = info.size;
        type = info.type;
      }
      
      // Skip small blobs that aren't m3u8
      if (size != null && size < 512 * 1024 && info?.kind !== 'm3u8') {
        return;
      }
    }
    
    // Determine media kind
    const isHls = isM3U8Url(url) || (isBlob(url) && blobRegistry.get(url)?.kind === 'm3u8');
    const isVideo = isVideoUrl(url) || (isBlob(url) && blobRegistry.get(url)?.kind === 'video');
    
    const kind = isHls ? 'hls' : isVideo ? 'video' : null;
    if (!kind) return;
    
    // Create and register item
    const item = createMediaItem(url, kind, { size, type });
    
    if (state.addItem(item)) {
      onItemDetected(item);
    }
  } catch (e) {
    console.error('[SG] processUrl error:', e);
  }
}

// ============================================
// Public API
// ============================================

let initialized = false;

export function initDetection(): void {
  if (initialized) return;
  initialized = true;
  
  // Wire up hooks
  setDetectionCallback((url) => debounceDetect(url, processUrl));
  setScanCallback((url) => debounceDetect(url, processUrl));
  
  // Install network hooks immediately
  installHooks();
  
  // Scan videos after DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      scanVideos();
      startVideoObserver();
    });
  } else {
    scanVideos();
    startVideoObserver();
  }
}

export { scanVideos, startVideoObserver, stopVideoObserver } from './video-scanner';

====================
File: src/detection/video-scanner.ts
====================

import { state } from '../state';

type ScanCallback = (url: string) => void;

let onScan: ScanCallback = () => {};

/**
 * Set the scan callback
 */
export function setScanCallback(cb: ScanCallback): void {
  onScan = cb;
}

/**
 * Watch a video element for source changes
 */
function watchVideo(video: HTMLVideoElement): void {
  if (state.watchedVideos.has(video)) return;
  state.watchedVideos.add(video);
  
  const emitSources = () => {
    const sources = [
      video.currentSrc || video.src,
      ...Array.from(video.querySelectorAll('source')).map(s => s.src),
    ].filter(Boolean);
    
    sources.forEach(onScan);
  };
  
  // Listen for media events
  const events = ['loadstart', 'loadedmetadata', 'canplay'] as const;
  events.forEach(ev => video.addEventListener(ev, emitSources));
  
  // Emit current sources immediately
  emitSources();
}

/**
 * Scan document for video elements
 */
export function scanVideos(): void {
  document.querySelectorAll('video').forEach(v => watchVideo(v as HTMLVideoElement));
}

/**
 * Start MutationObserver for dynamic videos
 */
let observer: MutationObserver | null = null;

export function startVideoObserver(): void {
  if (observer) return;
  
  observer = new MutationObserver(mutations => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (!(node instanceof Element)) continue;
        
        if (node.tagName === 'VIDEO') {
          watchVideo(node as HTMLVideoElement);
        } else {
          node.querySelectorAll?.('video')?.forEach(v => {
            watchVideo(v as HTMLVideoElement);
          });
        }
      }
    }
  });
  
  observer.observe(document.documentElement, {
    childList: true,
    subtree: true,
  });
}

export function stopVideoObserver(): void {
  observer?.disconnect();
  observer = null;
}

====================
File: src/ui/components.ts
====================

import { html, render, nothing, type TemplateResult } from 'lit-html';
import type { MediaItem, ProgressCardController } from '../types';
import { CFG } from '../config';
import { ICONS } from './icons';
import { formatBytes, uid } from '../utils';

// ============================================
// Clipboard
// ============================================

async function copyToClipboard(text: string, btn: HTMLElement): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
  } catch {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.cssText = 'position:fixed;opacity:0;pointer-events:none';
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand('copy');
    } catch {
      document.body.removeChild(textarea);
      return false;
    }
    document.body.removeChild(textarea);
  }
  
  const originalHTML = btn.innerHTML;
  btn.innerHTML = ICONS.check;
  btn.classList.add('copied');
  setTimeout(() => {
    btn.innerHTML = originalHTML;
    btn.classList.remove('copied');
  }, 1500);
  return true;
}

// ============================================
// FAB Component
// ============================================

export interface FabState {
  show: boolean;
  busy: boolean;
  idle: boolean;
  count: number;
}

export function renderFab(
  container: HTMLElement,
  fabState: FabState,
  onClick: () => void
): void {
  const classes = [
    'sg-fab',
    fabState.show ? 'show' : '',
    fabState.busy ? 'busy' : '',
    fabState.idle ? 'idle' : '',
  ].filter(Boolean).join(' ');
  
  const template = html`
    <button
      class=${classes}
      title="Download detected media"
      @click=${onClick}
      ?disabled=${fabState.busy}
    >
      <span .innerHTML=${ICONS.download}></span>
      <span class=${`sg-badge ${fabState.count > 0 ? 'show' : ''}`}>
        ${fabState.count}
      </span>
    </button>
  `;
  
  render(template, container);
}

// ============================================
// Modal Panel Component
// ============================================

export function renderModal(
  container: HTMLElement,
  show: boolean,
  title: string,
  items: MediaItem[],
  showFilter: boolean,
  excludeSmall: boolean,
  onClose: () => void,
  onSelect: (item: MediaItem) => void,
  onFilterChange: (checked: boolean) => void
): void {
  const anySizeKnown = items.some(i => i.size != null);
  
  const renderItem = (item: MediaItem) => {
    const shortUrl = item.url.length > 65 ? item.url.slice(0, 65) + 'â€¦' : item.url;
    
    const badges: TemplateResult[] = [];
    if (item.kind === 'hls') {
      if (item.hlsType === 'master') {
        badges.push(html`<span class="sg-badge-type master">Master</span>`);
      } else if (item.hlsType === 'media') {
        badges.push(html`<span class="sg-badge-type video">Video</span>`);
      } else {
        badges.push(html`<span class="sg-badge-type video">HLS</span>`);
      }
      if (item.isLive) {
        badges.push(html`<span class="sg-badge-type live">Live</span>`);
      }
      if (item.encrypted) {
        badges.push(html`<span class="sg-badge-type encrypted">ðŸ”’</span>`);
      }
    } else if (item.kind === 'video') {
      badges.push(html`<span class="sg-badge-type direct">Direct</span>`);
    }
    
    const handleCopy = (e: Event) => {
      e.stopPropagation();
      copyToClipboard(item.url, e.currentTarget as HTMLElement);
    };
    
    const handleClick = (e: Event) => {
      if (!(e.target as HTMLElement).closest('.sg-copy-btn')) {
        onSelect(item);
      }
    };
    
    const handleKeydown = (e: KeyboardEvent) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        onSelect(item);
      }
    };
    
    return html`
      <div
        class="sg-item"
        role="button"
        tabindex="0"
        @click=${handleClick}
        @keydown=${handleKeydown}
      >
        <div class="sg-item-top">
          <div class="sg-item-title">
            <span>${item.label}</span>
            ${badges}
          </div>
          ${item.size ? html`<span class="sg-item-size">${formatBytes(item.size)}</span>` : nothing}
          <button class="sg-copy-btn" title="Copy URL" @click=${handleCopy}>
            <span .innerHTML=${ICONS.copy}></span>
          </button>
        </div>
        ${item.sublabel ? html`<div class="sg-item-sub">${item.sublabel}</div>` : nothing}
        <div class="sg-item-url" title=${item.url}>${shortUrl}</div>
      </div>
    `;
  };
  
  const handleBackdropClick = (e: Event) => {
    if (e.target === e.currentTarget) onClose();
  };
  
  const template = html`
    <div
      class=${`sg-modal ${show ? 'show' : ''}`}
      @click=${handleBackdropClick}
    >
      <div class="sg-card" role="dialog" aria-modal="true">
        <div class="sg-card-head">
          <div class="sg-card-title">${title}</div>
          <button class="sg-btn" title="Close" @click=${onClose}>
            <span .innerHTML=${ICONS.close}></span>
          </button>
        </div>
        <div class="sg-card-body">
          ${showFilter && anySizeKnown ? html`
            <label class="sg-option">
              <input
                type="checkbox"
                ?checked=${excludeSmall}
                @change=${(e: Event) => onFilterChange((e.target as HTMLInputElement).checked)}
              >
              Exclude small (&lt; 1MB)
            </label>
          ` : nothing}
          <div class="sg-list">
            ${items.length > 0
              ? items.map(renderItem)
              : html`<div class="sg-empty">No media detected yet.</div>`
            }
          </div>
        </div>
      </div>
    </div>
  `;
  
  render(template, container);
}

// ============================================
// Progress Card (Fixed Implementation)
// ============================================

class ProgressCardImpl implements ProgressCardController {
  private container: HTMLElement;
  private element: HTMLDivElement;
  private minimized = false;
  private percent = 0;
  private statusText: string;
  private isPaused = false;
  private onStopFn?: () => 'paused' | 'resumed';
  private onCancelFn?: () => void;
  private title: string;
  private src: string;
  
  constructor(container: HTMLElement, title: string, src: string, segs = 0) {
    this.container = container;
    this.title = title;
    this.src = src;
    this.statusText = segs ? `${segs} segs` : '';
    
    this.element = document.createElement('div');
    this.element.className = 'sg-progress';
    this.element.id = `sg-progress-${uid()}`;
    this.container.appendChild(this.element);
    
    this.render();
  }
  
  private render(): void {
    const handleStop = () => {
      if (this.onStopFn) {
        const result = this.onStopFn();
        this.isPaused = result === 'paused';
        this.render();
      }
    };
    
    const handleMinimize = () => {
      this.minimized = !this.minimized;
      this.render();
    };
    
    const handleCancel = () => {
      this.onCancelFn?.();
    };
    
    const template = html`
      <div class="sg-progress-row">
        <div class="sg-progress-name" title=${this.src}>${this.title}</div>
        <div class="sg-progress-ctrls">
          ${this.onStopFn ? html`
            <button 
              class="sg-btn sg-btn-small" 
              title=${this.isPaused ? 'Resume' : 'Pause'} 
              @click=${handleStop}
            >
              <span .innerHTML=${this.isPaused ? ICONS.play : ICONS.pause}></span>
            </button>
          ` : nothing}
          <button 
            class="sg-btn sg-btn-small btn-minimize" 
            title=${this.minimized ? 'Show' : 'Hide'} 
            @click=${handleMinimize}
          >
            <span .innerHTML=${this.minimized ? ICONS.maximize : ICONS.minimize}></span>
          </button>
          <button class="sg-btn sg-btn-small" title="Cancel" @click=${handleCancel}>
            <span .innerHTML=${ICONS.cancel}></span>
          </button>
        </div>
      </div>
      <div class="sg-progress-bar">
        <div class="sg-progress-fill" style="width: ${this.percent}%"></div>
      </div>
      <div class="sg-progress-status">
        <span>${this.statusText}</span>
        <span>${Math.floor(this.percent)}%</span>
      </div>
    `;
    
    this.element.className = `sg-progress ${this.minimized ? 'minimized' : ''}`;
    render(template, this.element);
  }
  
  update(percent: number, text = ''): void {
    this.percent = Math.max(0, Math.min(100, percent));
    this.statusText = text;
    this.render();
  }
  
  done(ok = true, msg?: string): void {
    const fill = this.element.querySelector('.sg-progress-fill') as HTMLElement;
    if (fill) {
      fill.style.background = ok ? '#10b981' : '#e74c3c';
    }
    this.percent = 100;
    this.statusText = msg || (ok ? 'âœ“' : 'âœ—');
    this.render();
    setTimeout(() => this.remove(), 2200);
  }
  
  remove(): void {
    this.element.remove();
  }
  
  setOnStop(fn: () => 'paused' | 'resumed'): void {
    this.onStopFn = fn;
    this.render();
  }
  
  setOnCancel(fn: () => void): void {
    this.onCancelFn = fn;
  }
}

export function createProgressCard(
  container: HTMLElement,
  title: string,
  src: string,
  segs = 0
): ProgressCardController {
  return new ProgressCardImpl(container, title, src, segs);
}

====================
File: src/ui/icons.ts
====================

/**
 * SVG icons as template strings
 */

export const ICONS = {
  download: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
    <path d="M7 10l5 5 5-5"/>
    <path d="M12 15V3"/>
  </svg>`,
  
  close: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M18 6L6 18M6 6l12 12"/>
  </svg>`,
  
  copy: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <rect x="9" y="9" width="13" height="13" rx="2"/>
    <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
  </svg>`,
  
  check: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
    <path d="M20 6L9 17l-5-5"/>
  </svg>`,
  
  pause: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <rect x="6" y="4" width="4" height="16"/>
    <rect x="14" y="4" width="4" height="16"/>
  </svg>`,
  
  play: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polygon points="5 3 19 12 5 21 5 3"/>
  </svg>`,
  
  cancel: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="12" cy="12" r="10"/>
    <path d="M15 9l-6 6M9 9l6 6"/>
  </svg>`,
  
  minimize: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M19 9l-7 7-7-7"/>
  </svg>`,
  
  maximize: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M5 15l7-7 7 7"/>
  </svg>`,
} as const;

export type IconName = keyof typeof ICONS;

====================
File: src/ui/index.ts
====================

import { CFG } from '../config';
import { state } from '../state';
import { STYLES } from './styles';
import { renderFab, renderModal, createProgressCard, type FabState } from './components';
import type { MediaItem, ProgressCard } from '../types';

// ============================================
// State
// ============================================

let mounted = false;
let fabContainer: HTMLDivElement;
let modalContainer: HTMLDivElement;
let toastContainer: HTMLDivElement;

let fabState: FabState = {
    show: false,
    busy: false,
    idle: false,
    count: 0,
};

let modalState = {
    show: false,
    title: 'Select Media',
    items: [] as MediaItem[],
};

let idleTimeout: ReturnType<typeof setTimeout> | null = null;
let pendingPicker: {
    resolve: (item: MediaItem | null) => void;
    title: string;
    filterable: boolean;
} | null = null;

// ============================================
// Mount
// ============================================

export function mountUI(): void {
    if (!CFG.IS_TOP || mounted) return;

    if (!document.body) {
        document.addEventListener('DOMContentLoaded', mountUI, { once: true });
        return;
    }

    // Inject styles
    GM_addStyle(STYLES);

    // Create containers
    fabContainer = document.createElement('div');
    fabContainer.id = 'sg-fab-container';
    document.body.appendChild(fabContainer);

    modalContainer = document.createElement('div');
    modalContainer.id = 'sg-modal-container';
    document.body.appendChild(modalContainer);

    toastContainer = document.createElement('div');
    toastContainer.id = 'sg-toast-container';
    toastContainer.className = 'sg-toast';
    document.body.appendChild(toastContainer);

    mounted = true;

    // Initial render
    updateFab();
    updateModal();

    // FAB hover handlers
    fabContainer.addEventListener('mouseenter', clearIdle);
    fabContainer.addEventListener('mouseleave', setIdle);
}

// ============================================
// FAB
// ============================================

function updateFab(): void {
    if (!mounted) return;
    renderFab(fabContainer, fabState, handleFabClick);
}

export function showFab(): void {
    fabState.show = true;
    fabState.count = state.validCount;
    updateFab();
    clearIdle();
    setIdle();
}

export function hideFab(): void {
    fabState.show = false;
    updateFab();
}

export function setFabBusy(busy: boolean): void {
    fabState.busy = busy;
    updateFab();
}

export function updateBadge(): void {
    fabState.count = state.validCount;
    updateFab();
}

function setIdle(): void {
    if (idleTimeout) clearTimeout(idleTimeout);
    idleTimeout = setTimeout(() => {
        fabState.idle = true;
        updateFab();
    }, CFG.UI_IDLE_MS);
}

function clearIdle(): void {
    fabState.idle = false;
    if (idleTimeout) clearTimeout(idleTimeout);
    updateFab();
}

// ============================================
// Modal
// ============================================

function updateModal(): void {
    if (!mounted) return;

    const items = modalState.show ? getFilteredItems() : [];

    renderModal(
        modalContainer,
        modalState.show,
        modalState.title,
        items,
        pendingPicker?.filterable ?? true,
        state.excludeSmall,
        closeModal,
        handleItemSelect,
        handleFilterChange
    );
}

function getFilteredItems(): MediaItem[] {
    const items = modalState.items.length > 0 ? modalState.items : state.getFilteredItems();

    if (!state.excludeSmall) return items;

    return items.filter(
        item => item.size == null || item.size >= CFG.SMALL_BYTES
    );
}

export function openModal(title = 'Select Media', items?: MediaItem[]): void {
    modalState.show = true;
    modalState.title = title;
    modalState.items = items ?? [];
    updateModal();
}

export function closeModal(): void {
    modalState.show = false;
    modalState.items = [];
    updateModal();

    if (pendingPicker) {
        pendingPicker.resolve(null);
        pendingPicker = null;
    }
}

function handleItemSelect(item: MediaItem): void {
    closeModal();

    if (pendingPicker) {
        pendingPicker.resolve(item);
        pendingPicker = null;
    } else {
        // Trigger download
        onItemSelected?.(item);
    }
}

function handleFilterChange(checked: boolean): void {
    state.setExcludeSmall(checked);
    updateModal();
}

// ============================================
// Picker
// ============================================

export function pickFromList(
    items: MediaItem[],
    options: { title?: string; filterable?: boolean } = {}
): Promise<MediaItem | null> {
    const { title = 'Select Media', filterable = true } = options;

    return new Promise(resolve => {
        pendingPicker = { resolve, title, filterable };
        openModal(title, items);
    });
}

// ============================================
// Progress
// ============================================

export function createProgress(
    title: string,
    src: string,
    segs = 0
): ProgressCard {
    if (!mounted) mountUI();
    return createProgressCard(toastContainer, title, src, segs);
}

// ============================================
// Menu Commands
// ============================================

export function registerMenuCommands(): void {
    if (!CFG.IS_TOP) return;

    GM_registerMenuCommand('Show Download Panel', () => {
        mountUI();
        showFab();
        handleFabClick();
    });

    GM_registerMenuCommand('Clear Cache', () => {
        state.clear();
        updateBadge();
        alert('Cache cleared');
    });
}

// ============================================
// Callbacks
// ============================================

let onFabClick: (() => void) | null = null;
let onItemSelected: ((item: MediaItem) => void) | null = null;

export function setUICallbacks(cbs: {
    onFabClick?: () => void;
    onItemSelected?: (item: MediaItem) => void;
}): void {
    if (cbs.onFabClick) onFabClick = cbs.onFabClick;
    if (cbs.onItemSelected) onItemSelected = cbs.onItemSelected;
}

function handleFabClick(): void {
    clearIdle();
    setIdle();
    onFabClick?.();
}

// ============================================
// Refresh
// ============================================

export function refreshUI(): void {
    updateBadge();
    if (modalState.show) {
        updateModal();
    }
}

====================
File: src/ui/styles.ts
====================

/**
 * CSS styles for the UI
 */

export const STYLES = `
:root {
  --sg-bg: #1e1e1e;
  --sg-bg-2: #252525;
  --sg-bg-3: #2d2d2d;
  --sg-border: #353535;
  --sg-border-2: #404040;
  --sg-fg: #e0e0e0;
  --sg-fg-dim: #aaa;
  --sg-fg-dimmer: #888;
  --sg-ok: #10b981;
  --sg-bad: #e74c3c;
  --sg-badge: #dc3545;
  --sg-radius: 8px;
  --sg-font: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
  --sg-mono: ui-monospace, 'SF Mono', Consolas, monospace;
}

@keyframes sg-spin {
  to { transform: rotate(360deg); }
}

/* FAB Button */
.sg-fab {
  position: fixed;
  right: 16px;
  bottom: 16px;
  z-index: 2147483647;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  background: var(--sg-bg-3);
  color: #fff;
  border: 1px solid var(--sg-border-2);
  cursor: pointer;
  overflow: visible;
  font-family: var(--sg-font);
  transition: opacity 0.2s, background 0.15s;
}

.sg-fab.show { display: flex; }
.sg-fab.idle { opacity: 0.5; }
.sg-fab:hover { background: #353535; opacity: 1; }
.sg-fab.busy svg { opacity: 0; }

.sg-fab.busy::after {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  border: 2px solid var(--sg-border-2);
  border-top-color: #fff;
  border-radius: 50%;
  animation: sg-spin 0.6s linear infinite;
}

.sg-fab svg { width: 16px; height: 16px; }

/* Badge */
.sg-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  background: var(--sg-badge);
  color: #fff;
  font-weight: 600;
  font-size: 10px;
  padding: 3px 5px;
  border-radius: 10px;
  display: none;
  line-height: 1;
  border: 2px solid var(--sg-bg);
  min-width: 18px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.sg-badge.show { display: inline-block; }

/* Modal Overlay */
.sg-modal {
  position: fixed;
  inset: 0;
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.75);
  backdrop-filter: blur(4px);
  font-family: var(--sg-font);
}

.sg-modal.show { display: flex; }

/* Card */
.sg-card {
  background: var(--sg-bg);
  color: var(--sg-fg);
  border: 1px solid var(--sg-border-2);
  border-radius: 10px;
  width: min(520px, 94vw);
  max-height: 84vh;
  overflow: hidden;
}

.sg-card-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 16px;
  border-bottom: 1px solid #2d2d2d;
}

.sg-card-title {
  font-size: 15px;
  font-weight: 600;
  color: #fff;
}

.sg-card-body {
  padding: 12px 16px 16px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  overflow-y: auto;
  max-height: calc(84vh - 110px);
}

.sg-card-body::-webkit-scrollbar { width: 6px; }
.sg-card-body::-webkit-scrollbar-thumb { background: var(--sg-border-2); border-radius: 3px; }

/* Buttons */
.sg-btn {
  background: var(--sg-bg-3);
  border: 1px solid var(--sg-border-2);
  color: var(--sg-fg-dim);
  border-radius: var(--sg-radius);
  padding: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 32px;
  min-height: 32px;
  transition: background 0.15s, color 0.15s;
}

.sg-btn:hover { background: #353535; color: #fff; }
.sg-btn svg { width: 16px; height: 16px; }

.sg-btn-small {
  padding: 6px 8px;
  min-width: auto;
  min-height: auto;
}

.sg-btn-small svg { width: 13px; height: 13px; }

/* Checkbox option */
.sg-option {
  display: flex;
  align-items: center;
  gap: 9px;
  font-size: 12px;
  color: var(--sg-fg-dim);
  padding: 10px 12px;
  background: var(--sg-bg-2);
  border-radius: var(--sg-radius);
  border: 1px solid var(--sg-border);
}

.sg-option input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #fff;
  margin: 0;
}

/* Item List */
.sg-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.sg-item {
  background: var(--sg-bg-2);
  border: 1px solid var(--sg-border);
  border-radius: var(--sg-radius);
  padding: 12px 14px;
  cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}

.sg-item:hover {
  background: #2d2d2d;
  border-color: var(--sg-border-2);
}

.sg-item-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 6px;
}

.sg-item-title {
  font-weight: 600;
  font-size: 13px;
  color: #fff;
  line-height: 1.4;
  flex: 1;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 6px;
}

.sg-item-url {
  font-size: 11px;
  color: var(--sg-fg-dimmer);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-family: var(--sg-mono);
}

.sg-item-sub {
  font-size: 10px;
  color: #666;
  margin-top: 4px;
  margin-bottom: 2px;
}

.sg-item-size {
  font-size: 11px;
  color: #888;
  margin-left: auto;
  white-space: nowrap;
  padding-left: 8px;
}

/* Type Badges */
.sg-badge-type {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.sg-badge-type.master { background: #6366f1; color: #fff; }
.sg-badge-type.video { background: #10b981; color: #fff; }
.sg-badge-type.direct { background: #f59e0b; color: #fff; }
.sg-badge-type.live { background: #ef4444; color: #fff; }
.sg-badge-type.encrypted { background: #8b5cf6; color: #fff; }

/* Copy Button */
.sg-copy-btn {
  background: var(--sg-bg-3);
  border: 1px solid var(--sg-border-2);
  color: var(--sg-fg-dim);
  border-radius: 6px;
  padding: 7px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
}

.sg-copy-btn:hover { background: #353535; color: #fff; }
.sg-copy-btn svg { width: 13px; height: 13px; }
.sg-copy-btn.copied { background: #28a745; border-color: #28a745; color: #fff; }

/* Empty State */
.sg-empty {
  padding: 32px;
  color: var(--sg-fg-dimmer);
  font-size: 13px;
  text-align: center;
}

/* Toast Container */
.sg-toast {
  position: fixed;
  right: 16px;
  bottom: 72px;
  z-index: 2147483646;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 380px;
  max-height: 70vh;
  overflow-y: auto;
  align-items: flex-end;
  font-family: var(--sg-font);
}

.sg-toast::-webkit-scrollbar { width: 5px; }
.sg-toast::-webkit-scrollbar-thumb { background: var(--sg-border-2); border-radius: 3px; }

/* Progress Card */
.sg-progress {
  background: var(--sg-bg);
  color: var(--sg-fg);
  border: 1px solid var(--sg-border-2);
  border-radius: 10px;
  padding: 13px 15px;
  min-width: 280px;
  display: flex;
  flex-direction: column;
}

.sg-progress-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 9px;
}

.sg-progress-name {
  font-weight: 600;
  font-size: 13px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 230px;
  color: #fff;
}

.sg-progress-ctrls {
  display: flex;
  gap: 6px;
  margin-left: auto;
}

.sg-progress-bar {
  height: 7px;
  background: var(--sg-bg-2);
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid var(--sg-border);
}

.sg-progress-fill {
  height: 7px;
  width: 0;
  background: #fff;
  transition: width 0.1s;
}

.sg-progress-status {
  margin-top: 6px;
  font-size: 11px;
  display: flex;
  justify-content: space-between;
}

.sg-progress-status span:first-child { color: #999; }

/* Minimized Progress */
.sg-progress.minimized {
  padding: 6px;
  min-width: auto;
  width: auto;
  display: inline-flex;
}

.sg-progress.minimized .sg-progress-bar,
.sg-progress.minimized .sg-progress-status,
.sg-progress.minimized .sg-progress-name { display: none !important; }

.sg-progress.minimized .sg-progress-row:first-child { margin-bottom: 0; justify-content: center; }
.sg-progress.minimized .sg-progress-ctrls { margin: 0; gap: 0; }
.sg-progress.minimized .sg-progress-ctrls > :not(.btn-minimize) { display: none !important; }

/* Mobile */
@media (max-width: 640px) {
  .sg-fab { right: 12px; bottom: 12px; width: 46px; height: 46px; }
  .sg-fab svg { width: 15px; height: 15px; }
  .sg-toast { left: 12px; right: 12px; bottom: 68px; max-width: none; }
  .sg-card { max-height: 90vh; border-radius: 10px; }
  .sg-card-body { max-height: calc(90vh - 100px); }
}
`;
